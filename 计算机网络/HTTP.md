# HTTP

无连接（一旦返回请求，tcp连接就关闭了）、无状态、简单快捷方便

## HTTP有哪些方法

- GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器
- POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。
- PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。
- HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。
- DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。
- OPTIONS：查询相应URI支持的HTTP方法。

## Cookie和Session

复杂数据首选Session，Cookie只能存ascii码。隐私数据存在cookie中可以先加密，再通过服务器解密。不应该将用户所有信息存在Session中，开销大。浏览器一般对cookie的大小有限制。

## get和post

1. GET请求一般用于去请求获取数据，POST一般作为发送数据到后台时使用

2. GET请求也可传参到后台，但是其参数在浏览器的地址栏的url中可见，所以隐私性安全性较差，且参数长度也是有限制的。POST请求传递参数放在Request body中，不会在url中显示，比GET要安全，且参数长度无限制

3. GET请求刷新浏览器或回退时没有影响，POST回退时会重新提交数据请求

4. GET 请求可被**缓存**，POST 请求不会被缓存

5. GET 请求保留在浏览器**历史记录**中，POST 请求不会保留在浏览器历史记录中

6. GET 请求可被收藏为**书签**，POST 不能被收藏为书签

7. GET请求只能进行url编码（application/x-www-form-urlencoded），POST支持多种编码方式（application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。）

8. GET请求比较常见的方式是通过url地址栏请求，POST最常见是通过form表单发送数据请求

## 和HTTPS的区别

HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。

https速度会慢

SSL保证网络通信的安全和数据的完整性，采用了两种手段：身份认证（CA）和数据加密（对称和非对称）。

### 一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步：

1. 客户端向服务器发起HTTPS请求，连接到服务器的443端口

2. 服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。

3. 服务器将自己的**公钥发送给客户端**。

4. 客户端收到服务器端的证书之后（CA证书和公钥一起发过来），会对**证书进行检查**，验证其合法性，如果发现发现证书有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性，关于客户端如何验证数字证书的合法性，下文会进行说明。如果公钥合格，那么**客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥**，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。

5. 客户端会发起HTTPS中的第二个HTTP请求，将**加密之后的客户端密钥发送给服务器**。

6. 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行**非对称解密**，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行**对称加密**，这样数据就变成了密文。

7. 然后服务器将加密后的密文**发送给客户端**。

8. 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。

### 对称加密和非对称加密

对称加密是指发送和接受双方使用相同的秘钥对消息进行加密和解密。

非对称加密是指发送方使用接收方公布的公钥进行加密消息，接收方使用自己的私钥进行解密。

https在加密过程中，使用非对称加密传输对称加密秘钥，再通过对称加密技术对数据进行加密。

### CA证书



### 状态码

| 分类 | 分类描述                                           |
| :--- | :------------------------------------------------- |
| 1**  | 信息，**服务器收到请求**，需要请求者继续执行操作   |
| 2**  | **成功，操作被成功接收并处理**                     |
| 3**  | **重定向**，需要进一步的操作以完成请求             |
| 4**  | **客户端错误**，请求包含语法错误或无法完成请求     |
| 5**  | **服务器错误**，服务器在处理请求的过程中发生了错误 |

常用

- **200** - 请求成功

- 300 - 提供多个资源地址功浏览器选择
- **301** - 资源（网页等）被永久转移到其它URL
- 302 - 资源（网页等）临时转移到其它URL（301是指旧地址已经不存在数据了，302是同时存在，一般搜索引擎抓取的时候会定向到新url但是保留旧地址）
- 400 - 客户端语法错误（提交的字段出错）
- **403** - 拒绝访问（客户端证书失效、或者）
- **404** - 请求的资源（网页等）不存在
- 500 - 内部服务器错误（可能是服务器重启或者忙碌）
- 502 - 网关或代理服务器从服务器得到一个无效的响应
- 504 - 网关超时

## HTTP1.0、1.1、2.0

### HTTP1.0

> HTTP1.0是1996年引入的

- HTTP1.0仅提供了最基本的认证，用户名和密码都未加密
- HTTP1.0仅支持**短连接**，每次发送数据都会经过TCP三次握手和四次挥手，效率低
- HTTP1.0只使用了`header`的`if=modified-Since`和`Expires`作为缓存失效的标准
- HTTP1.0不支持**端点续传**，每次发送数据都会发送全部数据
- HTTP1.0认为每台计算机都只能绑定一个IP地址，不支持虚拟网络

------

### HTTP1.1

> HTTP1.1是1999年引入的

- HTTP1.1使用了**摘要算法**进行身份验证
- HTTP1.1默认使用**长连接**

> 只需要建立一次连接，可以传输多次数据，传输完成之后，只需要一次切断即可。通过请求头的`keep-alive`设置

- HTTP1.1支持**端点续传**

> 通过请求头的`Range`实现

- HTTP1.1使用了**虚拟网络**

> 在一台物理服务器上可以存在多个虚拟主机，共享一个IP地址

------

### HTTP2.0

> 2015年建立

- **头部压缩**：利用`HPACK`算法进行压缩

> 由于HTTP1.1头部经常出现Cookie、Accept、Sever、Range等字段可能会占用几百到几千字节，而body有时只有几十字节（“头重身轻”）

- **二进制格式**：HTTP2.0选择了更靠近TCP/IP的二进制格式，抛弃了ASCII码，提高了解析效率
- **强化安全**：HTTP2.0一般都跑在HTTPS上
- **多路复用**：一个连接上可以有多个请求

## HTTP格式

#### 1.协议部分

该`URL`的协议部分为`http:`，表示网页用的是`HTTP`协议，后面的`//`为分隔符

#### 2.域名部分

域名是`www.baidu.cn`，发送请求时，需要向`DNS`服务器解析`IP`。如果为了优化请求，可以直接用`IP`作为域名部分使用

#### 3.端口部分

域名后面的`80`表示端口，和域名之间用`:`分隔，端口不是一个`URL`的必须的部分。如果端口是`80`，也可以省略不写

#### 4.虚拟目录部分

从域名的第一个`/`开始到最后一个`/`为止，是虚拟目录的部分。其中，虚拟目录也不是`URL`必须的部分

#### 5.文件名部分

从域名最后一个`/`开始到`?`为止，是文件名部分；如果没有`?`，则是从域名最后一个`/`开始到`#`为止，是文件名部分；如果没有`?`和`#`，那么就从域名的最后一个`/`从开始到结束，都是文件名部分。文件名也不是一个`URL`的必须部分，如果没有文件名，则使用默认文件名

#### 6.锚部分

从`#`开始到最后，都是锚部分。可以定位到页面的锚点。锚也不是一个`URL`必须的部分

#### 7.参数部分

从`?`开始到`#`为止之间的部分是参数部分，又称为搜索部分、查询部分。如果有多个参数，各个参数之间用`&`作为分隔符。

## Request

![img](E:\VirtualNotebook\计算机网络\HTTP.assets\1843940-d3214aa6ebf47292.png)

抓包的`request`结构如下：

```
GET /mix/76.html?name=kelvin&password=123456 HTTP/1.1
Host: www.fishbay.cn
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Encoding: gzip, deflate, sdch
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6
```

#### 1.请求行

`GET`为请求类型，`/mix/76.html?name=kelvin&password=123456`为要访问的资源，`HTTP/1.1`是协议版本

#### 2.请求头部

从第二行起为请求头部，`Host`指出请求的目的地（主机域名）；`User-Agent`是客户端的信息，它是检测浏览器类型的重要信息，由浏览器定义，并且在每个请求中自动发送。

#### 3.空行

请求头后面必须有一个空行

#### 4.请求数据

请求的数据也叫请求体，可以添加任意的其它数据。这个例子的请求体为空。

## Response

![img](E:\VirtualNotebook\计算机网络\HTTP.assets\1843940-9161c0c67fb3bad1.jpg)

抓包的数据如下：

```
HTTP/1.1 200 OK
Server: nginx
Date: Mon, 20 Feb 2017 09:13:59 GMT
Content-Type: text/plain;charset=UTF-8
Vary: Accept-Encoding
Cache-Control: no-store
Pragrma: no-cache
Expires: Thu, 01 Jan 1970 00:00:00 GMT
Cache-Control: no-cache
Content-Encoding: gzip
Transfer-Encoding: chunked
Proxy-Connection: Keep-alive

{"code":200,"notice":0,"follow":0,"forward":0,"msg":0,"comment":0,"pushMsg":null,"friend":{"snsCo
```

#### 1.状态行

状态行由协议版本号、状态码、状态消息组成

#### 2.响应头

响应头是客户端可以使用的一些信息，如：`Date`（生成响应的日期）、`Content-Type`（MIME类型及编码格式）、`Connection`（默认是长连接）等等

#### 3.空行

响应头和响应体之间必须有一个空行

#### 4.响应体

响应正文，本例中是键值对信息