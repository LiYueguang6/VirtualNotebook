# 并发
***
## 线程状态转换
新建New
可运行Runable
阻塞Blocked
无限期等待Waiting
限期等待Timed Waiting
死亡Terminated
## 使用线程
三种方法：
* 实现Runnable接口
* 实现Callable接口
* 继承Thread类

实现Runnable和Callable接口的类只能当做一个可以在线程中运行的任务而不是真正意义的线程，因此最后还需要通过Thread来调用。
### 实现Runnable方法
需要实现run()方法，通过Thread调用start()方法来启动线程。
### 实现Callable方法
和Runnable相比Callable可以有返回值，返回值通过FutureTask进行封装。先FutureTask封装，再thread封装，start启动，使用FutureTask.get()获取返回值。
### 继承Thread类
实现run方法。Thread类也实现了Runable接口，直接start线程对象就可以启动。

区别：**实现接口好**
* Java不支持多重继承，因此继承了Thread类就不可以继承其他类
* 类要求可执行就可以，继承Thread类开销大

## 基础线程机制
### Executer
### Daemon
守护线程是程序运行时在后台提供服务的线程。非守护线程结束后，守护线程即失效。设置守护线程：```thread.setDeamon(true)```
* sleep

* yield
该方法是静态方法，在run中调用方法即声明该进程已经完成生命周期中重要部分，建议其他进程可以执行。但是实际操作中，该线程还是会有机会被调度器选中。

## 中断
interrupt()方法
注意：无限循环且没有sleep的线程不能用，但是可以添加interrupted()状态判断是否中止

Executor的中断包括
* shutdown
* shutdownNow
* submit：submit提交一个进行，会返回一个Future对象，```Future.cancel(true)```即可中断线程。

## 互斥同步
java有两种锁机制，控制多线程互斥访问 