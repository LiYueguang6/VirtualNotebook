# 并发
***
## 1 线程状态转换
新建New
可运行Runable
阻塞Blocked
无限期等待Waiting
限期等待Timed Waiting
死亡Terminated
## 2.使用线程
三种方法：
* 实现Runnable接口
* 实现Callable接口
* 继承Thread类

实现Runnable和Callable接口的类只能当做一个可以在线程中运行的任务而不是真正意义的线程，因此最后还需要通过Thread来调用。
### 2.1 实现Runnable方法
需要实现run()方法，通过Thread调用start()方法来启动线程。
### 2.2 实现Callable方法
和Runnable相比Callable可以有返回值，返回值通过FutureTask进行封装。先FutureTask封装，再thread封装，start启动，使用FutureTask.get()获取返回值。
### 2.3 继承Thread类
实现run方法。Thread类也实现了Runable接口，直接start线程对象就可以启动。

区别：**实现接口好**
* Java不支持多重继承，因此继承了Thread类就不可以继承其他类
* 类要求可执行就可以，继承Thread类开销大

## 3. 基础线程机制
### Executer
### Daemon
守护线程是程序运行时在后台提供服务的线程。非守护线程结束后，守护线程即失效。设置守护线程：```thread.setDeamon(true)```
* sleep

* yield
该方法是静态方法，在run中调用方法即声明该进程已经完成生命周期中重要部分，建议其他进程可以执行。但是实际操作中，该线程还是会有机会被调度器选中。

## 4. 中断
interrupt()方法
注意：无限循环且没有sleep的线程不能用，但是可以添加interrupted()状态判断是否中止

Executor的中断包括
* shutdown
* shutdownNow
* submit：submit提交一个进行，会返回一个Future对象，```Future.cancel(true)```即可中断线程。

## 5. 互斥同步
java有两种锁机制，控制多线程互斥访问
* JVM实现的synchronized
* JDK实现的ReentrantLock
### 5.1 synchronized
#### 同步一个代码块
**这个代码块只对同一个对象生效**
如果Executor调用了同一个对象的同一个带有synchronized代码块的方法两次，后一次就会等待前一次结束之后再运行。

#### 同步一个方法
synchronized修饰方法名称，同一个对象的同一个方法会等待同步进行。
#### 同步一个类
类中的方法中写
```
synchronized (SynchronizedExampl.class){
    //
}
```
两个线程调用两个**不同对象**的同一段这种语句，即可进行同步。

#### 同步一个静态方法
作用于整个类
synchronized修饰同一个类的不同的静态方法，不同对象调用这些静态方法，也进行同步。

### 5.2 ReentrantLock
作用于类。
ReentrantLock是java.util.concurrent包中的锁。
类中定义```private Lock lock = new ReentrantLock();```，在类中的方法里执行```lock.lock();```，方法最后要执行```lock.unlock();```确保释放锁，从而避免发生死锁。

### 5.3 比较
1. 锁的实现
   synchronized是JVM实现的，ReentrantLock是JDK实现的
2. 性能
3. 等待可中断
   ReentrantLock可中断
4. 公平锁
   synchronized的锁是非公平的，ReentrantLock实例化是参数为空或者false是非公平的。
5. 锁绑定多个条件
   ReentrantLock绑定多个Condition对象

**首先选用synchronized，因为这是JVM原生支持的，且不用担心锁释放问题。**

## 6. 线程协作
当多个线程一起工作解决某个问题时，如果某些部分必须在其他部分之前完成，要对线程进行协调。
### 6.1 join()
在线程中调用**另一个线程**的join()方法，会将**当前线程**挂起，不是忙等待，直到目标线程结束。
### wait()notify()nitifyAll()
它们属于Object的一部分，而不是Thread的一部分
调用wait使得线程等待某个条件，直到其他线程调用notify或者notifyAll来唤醒等待的线程。
**wait挂起会释放锁**

#### wait()和sleep()的区别
* wait()是Object的方法，而sleep()是Thread的静态方法；
* wait()会释放锁，sleep()不会。

### await()signal()signalAll()
