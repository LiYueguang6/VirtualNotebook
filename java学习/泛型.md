# Java泛型
泛型，即“参数化类型”。就是**将类型由原来的具体的类型参数化，类似于方法中的变量参数**，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。
例如：GenericClass<T>{}

一些常用的泛型类型变量：
> E：元素（Element），多用于java集合框架
> K：关键字（Key）
> N：数字（Number）
> T：类型（Type）
> V：值（Value）

#### 使用泛型的意义在于
1. 适用于多种数据类型执行相同的代码（代码复用）
2. 泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型）

### 泛型的使用方法
> + 定义一个泛型类：```public class GenericClass<T>{}```
> + 定义一个泛型接口：```public interface GenericIntercace<T>{}```
> > 实现泛型接口方式一：```public class ImplGenericInterface1<T> implements GenericIntercace<T>```
> > 实现泛型接口方式二：```public class ImplGenericInterface2 implements GenericIntercace<String> {}```
> + 定义一个泛型方法： ```private static<T> TgenericAdd(T a, T b) {}```

### 限定泛型类型变量
1,对类的限定：```public class TypeLimitForClass<T extends List & Serializable>{}```
2,对方法的限定：```public static<T extends Comparable<T>>T getMin(T a, T b) {}```

### 泛型中的约束和局限性
1. 不能实例化泛型类
2. 静态变量或方法不能引用泛型类型变量，但是静态泛型方法是可以的
3. 基本类型无法作为泛型类型
4. 无法使用instanceof关键字或==判断泛型类的类型
5. 泛型类的原生类型与所传递的泛型无关，无论传递什么类型，原生类是一样的
6. 泛型数组可以声明但无法实例化
7. 泛型类不能继承Exception或者Throwable
8. 不能捕获泛型类型限定的异常但可以将泛型限定的异常抛出


### 泛型类型继承规则
1,对于泛型参数是继承关系的泛型类之间是没有继承关系的
2,泛型类可以继承其它泛型类，例如: ```public class ArrayList<E> extends AbstractList<E>```
3,泛型类的继承关系在使用中同样会受到泛型类型的影响

### 通配符类型
1. ```<? extends Parent>``` 指定了泛型类型的上届
2. ```<? super Child>``` 指定了泛型类型的下届
3. ```<?>``` 指定了没有限制的泛型类型
![1](Java泛型%20-%20通配符类型.webp) 
### 参考
1. [Java泛型详解 - 简书](https://www.jianshu.com/p/986f732ed2f1)