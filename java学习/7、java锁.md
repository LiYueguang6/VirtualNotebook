# java锁

综述：首先说一下几个概念，乐观锁和悲观锁，……；自旋锁……可重入锁……公平锁……。其次是java对象头和monitor的概念。接着是java中具体的锁的实现，是通过synchronized和ReentrantLock实现的，……。synchronized本身是重量级锁，后来引入了锁的升级的概念，……。

## 一、基本概念

### 1.1 乐观锁

读的时候不加锁，修改的时候进行版本号比较，相同即加锁修改，否则重复。
### 1.2 悲观锁
读写都加锁。Synchronized
### 1.3 自旋锁
线程短时间cpu空转，否则线程要在阻塞挂起状态间切换

### 1.4 可重入锁

递归锁，递归函数里无需重复加锁，也不会阻塞。

**实现原理**：每一个锁关联着一个线程和一个计数器。调用一次上锁计数器加1，退出一个锁，计数器减1。计数器为0时释放锁。

### 1.5 公平锁和非公平锁



## 二、对象头和monitor

### 2.1 对象头

锁状态：

| biased_lock | lock |   状态   |
| :---------: | :--: | :------: |
|      0      |  01  |   无锁   |
|      1      |  01  |  偏向锁  |
|      0      |  00  | 轻量级锁 |
|      0      |  10  | 重量级锁 |
|      0      |  11  |  GC标记  |

### 2.2 monitor对象

## 三、重量级锁的升级过程

### 3.1 偏向锁

某一个线程获取偏向锁，只需要置换一次线程id即可，是个乐观锁。遇到锁的争用会升级轻量级锁或者重量级锁

### 3.2 轻量级锁

基于CAS方式

1.建立栈帧锁空间lock record，用于存储对象头的拷贝

2.拷贝要获取的对象的对象头到锁空间

3.通过CAS操作将对象锁的指针指向自己

4.1.重置对象头状态00

4.2如果更新失败，检查是否已经指向自己，否的话自旋，自旋结束以后未获得锁升级为重量级锁。

### 3.3 重量级锁

使用monitor实现，每一个对象都关联一个monitor，依赖于操作系统底层的mutex lock（互斥量）实现，所以需要在用户态和内核态下进行切换。

升级到重量级锁，对象头中写入指向monitor互斥量的指针。monitor则保存着锁拥有者的信息。重量级锁的更新就是monitor对象的更新。

## 四、Synchronized和ReentrantLock