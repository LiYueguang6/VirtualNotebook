# Java项目

## 描述：

基于SpringBoot开发的网上商城系统，作为自己学习和练习的项目。主要学习的内容是微服务场景下的远程服务调用，和基于redis的缓存技术。

构建模块：后台商品信息管理、商品详情页、购物车、模拟支付

## 问题：

### 1.业务逻辑拆分

对应数据库逻辑相近的表构建service，这样可以方便不同Controller的在某一个业务逻辑下操作数据库的表，也可以有效区分不同的业务逻辑，实现业务的高内聚低耦合。

### 2.zk简述

zookeeper可以充当一个服务注册表（Service Registry），让多个服务提供者形成一个集群，让服务消费者通过服务注册表获取具体的服务访问地址（ip+端口）去访问具体的服务提供者。实现不同服务间的交互。

### 3.mybatis简述

通过Mapper调用xml中写好的sql，把参数传递进去，再通过内部jdbc进行数据库交互，得到的结果再生成Dao层的对象的结果集。
（1）Mybatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。程序员直接编写原生态sql，可以严格控制sql执行性能，灵活度高。
（2）MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。
（3）通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和 statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。（从执行sql到返回result的过程）。
防止sql注入：Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；

### 4.rabbitmq

rabbitmq在项目中的主要作用是实现消息队列，进一步对项目进行解耦，各种服务之间并不需要直接通讯，可以进行异步交互。消息队列可以实现以下功能。

1. 可以实现异步进行，比如某一个服务生产出来的消息要被消费者响应，但是消费者不能及时响应，使用消息队列可以存储这个消息，防止生产者也进入阻塞，可以继续生产，而消费者只需从队列中读取消息即可。做**抢红包和秒杀**等功能时时，将消息放入mq队列中，再依次处理，减轻服务端压力。
2. 可以实现订阅发布的模式，一个生产者生产出来的消息可以转发到所有订阅了该消息的消费者，而不通服务之间不需要进行通讯，每个服务只关注自己的任务，加快任务的执行。例如订单系统发布到topic上，然后后台支付系统和库存管理系统就可以并行的执行相应的业务逻辑，例如：
	1. 添加商品信息后，库存管理和生成es索引可以同步进行。
	2. 支付成功后，通过消息队列通知订单系统，订单系统完成后通过



好处是：解耦、异步、削峰
除了可以使用rabbitMq等消息中间件，还可以自行通过redis的list实现消息队列。

### 5.redis的作用

1）缓存——商品信息、购物车，防止数据库频繁读写，也可以提高执行效率
2）消息队列——比较少用。可靠消息发布、消息确认、负载均衡等功能都需要自己实现
3）多级缓存
**4）缓存穿透**
恶意查询不存在的key，加重后端数据库的压力。
解决方法：对查询结果为空的情况进行缓存，存活时间可以设为久一点。把所有存在的key记录到一个布隆过滤器（redis支持bit的插入删除，天然优势。使用公式根据值的个数和误报率选取bit的位数和hash函数的个数）中，查询时过滤掉不存在的key，效率高但是存在误报。
**5）缓存雪崩**
多个缓存失效，后端数据库压力暴增
解决方法：搭建redis集群多级缓存；缓存失效后给后端数据库通过加锁限流，不同的key设置不同的过期时间，分散key失效的时间点
**6）缓存击穿**
热点缓存失效
解决方法：通过锁进行限流（分布式锁）
A.redis自带锁set  nx（只有不存在时才写入），因为锁是基于kv插入的，应用在具体业务上依然会产生并发问题，用redisson
B.redisson框架（可以理解为jedis+juc）结合apach压测

``````java
Jedis jedis = redisUtil.getJedis();
RLock lock = redissonClient.getLock("lock");// 声明锁
lock.lock();//上锁
try {
	String v = jedis.get("k");
	if (StringUtils.isBlank(v)) {
		v = "1";
    }
    jedis.set("k", (Integer.parseInt(v) + 1) + "");
}finally {
	jedis.close();
	lock.unlock();// 解锁
}
``````

### 6.购物车

当用户没有登录时向购物车添加商品是添加到cookie中，这样服务端没有存储的压力，当用户登录后，购物车的信息是同步到redis中和redis中已有的购物车合并，再返回cookie，序列化后存入redis中，实现持久化。

### 7.单点登录

早期方案：

1. 单一服务器，压力大无法扩展

2. Web应用集群，session共享。不同业务间不适合共享session，且sessionId存储在cookie中不安全
3. SSO（单点登录）：认证中心统一管理用户信息，可以自己设置安全策略。不同业务间也不会出现交叉影响。

SSO流程：

1. 用户首次登录，系统检测无cookie记录，则重定向到认证中心进行登录，认证中心颁发token。
2. 将token写入业务cookie中。
3. 其他业务检测到cookie中存在token，则自动转向认证中心认证



### 8.秒杀系统

1）先将秒杀商品库存预存到redis
2）秒杀开始后，在redis中预减库存，减为0该商品秒杀结束（redis是单线程的）
3）如果为了减轻对redis的访问压力，可以将用户提交的秒杀请求放到mq（比如RabbitMq）中
比如一共只有10件商品，一共有10万用户虎视眈眈，都几乎同一时间提交秒杀请求，
	3.1）可以将请求放到消息队列中，返回给前端是“排队中";
	3.2）消费者(队列的”消费者“）按照固定的速度从消息队列中取数据，创建订单到数据库（也就有条不紊的创建10个订单，数据库0冲击），
	3.3）虽然有可能是排到前10的用户，如果由于某种原因创建订单失败，就会将该用户的秒杀请求放到mq尾部，接着给队列中的其他用户创建订单
	3.4）创建订单成功的请求，将该请求从mq中移除，对用户发送短信”恭喜，秒杀成功！“
	3.5）成功创建10个订单之后（也就是秒杀结束），给队列中其他用户请求返回”秒杀失败“

### 9.活动倒计时



### 10.es