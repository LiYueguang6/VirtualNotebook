# 消息队列

## 主要消息队列

rabbitmq、activemq、kafka

不做说明一下实现和解决方法基于rabbitmq实现





## 面试题

### 1. mq如何保证消息不丢失

**消息丢失会出现在以下几个场景**

1. 生产者弄丢了数据
	生产者将数据发送到rabbitmq的时候，可能在传输过程中因为网络等问题而将数据弄丢了。
2. rabbitmq自己丢了数据
	如果没有开启rabbitmq的持久化，那么rabbitmq一旦重启，那么数据就丢了。所依必须开启持久化将消息持久化到磁盘，这样就算rabbitmq挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢失。除非极其罕见的情况，rabbitmq还没来得及持久化自己就挂了，这样可能导致一部分数据丢失。
3. 消费端弄丢了数据
	主要是因为消费者消费时，刚消费到，还没有处理，结果消费者就挂了，这样你重启之后，rabbitmq就认为你已经消费过了，然后就丢了数据。

**解决方案**

1. 生产者丢失消息
    ①：可以选择使用rabbitmq提供是**事务**功能，就是生产者在发送数据之前开启事务，然后发送消息，如果消息没有成功被rabbitmq接收到，那么生产者会受到异常报错，这时就可以回滚事务，然后尝试重新发送；如果收到了消息，那么就可以提交事务。

  ```java
  channel.txSelect();//开启事务
  try{
     //发送消息
  }catch(Exection e){
     channel.txRollback()；//回滚事务
     //重新提交
  } 
  ```

  缺点：rabbitmq事务已开启，就会变为**同步阻塞操作**，生产者会阻塞等待是否发送成功，**太耗性能**会造成吞吐量的下降。

  ②：可以开启**confirm模式**。在生产者那里设置开启了confirm模式之后，每次写的消息都会分配一个唯一的id，然后如何写入了rabbitmq之中，rabbitmq会给你回传一个ack消息，告诉你这个消息发送OK了；如果rabbitmq没能处理这个消息，会回调你一个nack接口，告诉你这个消息失败了，你可以进行重试。而且你可以结合这个机制知道自己在内存里维护每个消息的id，如果超过一定时间还没接收到这个消息的回调，那么你可以进行重发。

  ```
  //开启confirm
  channel.confirm();
  //发送成功回调
  public void ack(String messageId){      
  }    
  // 发送失败回调
  public void nack(String messageId){
      //重发该消息
  }
  
  ```

  **二者不同**
  事务机制是同步的，你提交了一个事物之后会阻塞住，但是confirm机制是异步的，发送消息之后可以接着发送下一个消息，然后rabbitmq会回调告知成功与否。
  一般在生产者这块避免丢失，都是用confirm机制。

2. rabbitmq自己弄丢了数据
    设置消息**持久化**到磁盘。设置持久化有两个步骤：
    ①创建queue的时候将其设置为持久化的，这样就可以保证rabbitmq持久化queue的**元数据**，但是不会持久化queue里面的数据。【元数据：】
    ②发送消息的时候将消息的deliveryMode设置为2，这样消息就会被设为持久化方式，此时rabbitmq就会将消息持久化到磁盘上。
    必须要**同时开启这两个**才可以。

  而且持久化可以跟生产的confirm机制配合起来，只有消息持久化到了磁盘之后，才会通知生产者ack，这样就算是在持久化之前rabbitmq挂了，数据丢了，生产者收不到ack回调也会进行消息重发。

3. 消费者弄丢了数据
	使用rabbitmq提供的ack机制，首先关闭rabbitmq的自动ack，然后每次在确保处理完这个消息之后，在代码里**手动调用ack**。这样就可以避免消息还没有处理完就ack。

### 2.mq如何保证消息不重复消费

