# RPC

远程服务调用，主要是指可以程序可以调用网络上其他服务的函数方法

需要解决的的问题：

1. 函数映射。本地调用时函数通过函数指针被调用，远程调用则需要对各个提供服务的函数进行统一的call id编码
2. 序列化和反序列化。远程调用过程无法通过内存来共享参数和数据，只能对传输的数据进行序列化，再在被调用的函数进行反序列化（甚至可能不是同一种语言，所以要对字节流进行处理）。
3. 网络传输。大部分RPC框架使用了tcp。还有http，java的netty。dubbo自己实现的dubbo协议

### NIO

不同于传统的阻塞io（bio）以字节流形式传输数据，nio是一种新的形式，以**块的方式**进行数据传输，NIO的本质核心是**io多路复用**。本质还是基于字节流实现了**通道**和**缓冲区**。

**通道**

1. 通道是对原 I/O 包中的流的**模拟**。到任何目的地(或来自任何地方)的所有数据都必须通过一个 Channel 对象（通道）。一个 Buffer 实质上是一个容器对象。发送给一个通道的所有对象都必须首先放到缓冲区中；同样地，从通道中读取的任何数据都要读到缓冲区中。 **Channel是一个对象，可以通过它读取和写入数据**。拿 NIO 与原来的 I/O 做个比较，通道就像是流。
2. 正如前面提到的，所有数据都通过 Buffer 对象来处理。您永远不会将字节直接写入通道中，相反，您是将数据写入包含一个或者多个字节的缓冲区。同样，您不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。【**程序发送->通道->缓冲区->程序读取**】

**缓冲区**

1. Buffer 是一个对象， 它包含一些要写入或者刚读出的数据。 在 NIO 中加入 Buffer 对象，体现了新库与原 I/O 的一个重要区别。在面向流的 I/O 中，您将数据直接写入或者将数据直接读到 Stream 对象中
2. 在 NIO 库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的。在写入数据时，它是写入到缓冲区中的。任何时候访问 NIO 中的数据，您都是将它放到缓冲区中。
3. 缓冲区实质上是一个**数组**。通常它是一个**字节数组**，但是也可以使用其他种类的数组。但是一个缓冲区不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程

**缓冲区的类型：**

```
ByteBuffer
CharBuffer
ShortBuffer
IntBuffer
LongBuffer
FloatBuffer
DoubleBuffer
```

## Netty

Netty 是一款基于 NIO（Nonblocking I/O，非阻塞IO）开发的**网络通信框架**，对比于 BIO（Blocking I/O，阻塞IO），他的并发性能得到了很大提高。难能可贵的是，在保证快速和易用性的同时，并没有丧失可维护性和性能等优势。

**Netty 的特点是什么？**

高并发：Netty 是一款基于 NIO（Nonblocking IO，非阻塞IO）开发的网络通信框架，对比于 BIO（Blocking I/O，阻塞IO），他的并发性能得到了很大提高。

传输快：Netty 的传输依赖于零拷贝特性，尽量减少不必要的内存拷贝，实现了更高效率的传输。

封装好：Netty 封装了 NIO 操作的很多细节，提供了易于使用调用接口。

**什么是 Netty 的零拷贝？**

Netty 的零拷贝主要包含三个方面：

Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用**堆外直接内存**进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写，JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。

Netty 提供了**组合 Buffer 对象**，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的 Buffer。

Netty 的文件传输采用了 transferTo 方法，它可以**直接将文件缓冲区的数据发送到目标 Channel**，避免了传统通过循环 write 方式导致的内存拷贝问题。

## Dubbo

![img](RPC.assets/20181002113745869)![img](RPC.assets/20181002113850939)



**Dubbo推荐使用什么序列化框架，你知道的还有哪些？**

推荐使用**Hessian**序列化，还有Duddo、FastJson、Java自带序列化。

**Dubbo默认使用的是什么通信框架，还有别的选择吗？**

Dubbo 默认使用 Netty 框架，也是推荐的选择，另外内容还集成有Mina、Grizzly。

**Dubbo有哪几种集群容错方案，默认是哪种？**

![img](RPC.assets/20181002113930188)

**17、Dubbo有哪几种负载均衡策略，默认是哪种？**

![img](RPC.assets/20181002113941952)

**18、注册了多个同一样的服务，如果测试指定的某一个服务呢？**

可以配置环境点对点直连，绕过注册中心，将以服务接口为单位，忽略注册中心的提供者列表。

**19、Dubbo支持服务多协议吗？**

Dubbo 允许配置多协议，在不同服务上支持不同协议或者同一服务上同时支持多种协议。

**20、当一个服务接口有多种实现时怎么做？**

当一个接口有多种实现时，可以用 group 属性来分组，服务提供方和消费方都指定同一个 group 即可。

**21、服务上线怎么兼容旧版本？**

可以用版本号（version）过渡，多个不同版本的服务注册到注册中心，版本号不同的服务相互间不引用。这个和服务分组的概念有一点类似。

**22、Dubbo可以对结果进行缓存吗？**

可以，Dubbo 提供了声明式缓存，用于加速热门数据的访问速度，以减少用户加缓存的工作量。

**23、Dubbo服务之间的调用是阻塞的吗？**

默认是同步等待结果阻塞的，支持异步调用。

Dubbo 是基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小，异步调用会返回一个 Future 对象。

异步调用流程图如下。

![img](RPC.assets/20181002113955917)

 

**24、Dubbo支持分布式事务吗？**

目前暂时不支持