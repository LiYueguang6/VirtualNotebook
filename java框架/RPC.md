# RPC

远程服务调用，主要是指可以程序可以调用网络上其他服务的函数方法

需要解决的的问题：

1. 函数映射。本地调用时函数通过函数指针被调用，远程调用则需要对各个提供服务的函数进行统一的call id编码
2. 序列化和反序列化。远程调用过程无法通过内存来共享参数和数据，只能对传输的数据进行序列化，再在被调用的函数进行反序列化（甚至可能不是同一种语言，所以要对字节流进行处理）。
3. 网络传输。大部分RPC框架使用了tcp。还有http，java的netty。dubbo自己实现的dubbo协议

### NIO

不同于传统的阻塞io（bio）以字节流形式传输数据，nio是一种新的形式，以**块的方式**进行数据传输，NIO的本质核心是**io多路复用**。本质还是基于字节流实现了**通道**和**缓冲区**。

**通道**

1. 通道是对原 I/O 包中的流的**模拟**。到任何目的地(或来自任何地方)的所有数据都必须通过一个 Channel 对象（通道）。一个 Buffer 实质上是一个容器对象。发送给一个通道的所有对象都必须首先放到缓冲区中；同样地，从通道中读取的任何数据都要读到缓冲区中。 **Channel是一个对象，可以通过它读取和写入数据**。拿 NIO 与原来的 I/O 做个比较，通道就像是流。
2. 正如前面提到的，所有数据都通过 Buffer 对象来处理。您永远不会将字节直接写入通道中，相反，您是将数据写入包含一个或者多个字节的缓冲区。同样，您不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。【程序发送->通道->缓冲区->程序读取】

**缓冲区**

1. Buffer 是一个对象， 它包含一些要写入或者刚读出的数据。 在 NIO 中加入 Buffer 对象，体现了新库与原 I/O 的一个重要区别。在面向流的 I/O 中，您将数据直接写入或者将数据直接读到 Stream 对象中
2. 在 NIO 库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的。在写入数据时，它是写入到缓冲区中的。任何时候访问 NIO 中的数据，您都是将它放到缓冲区中。
3. 缓冲区实质上是一个**数组**。通常它是一个**字节数组**，但是也可以使用其他种类的数组。但是一个缓冲区不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程

**缓冲区的类型：**

```
ByteBuffer
CharBuffer
ShortBuffer
IntBuffer
LongBuffer
FloatBuffer
DoubleBuffer
```



## Dubbo

