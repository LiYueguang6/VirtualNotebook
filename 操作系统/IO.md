# IO

## 两种CPU状态

内核态（Kernel Mode）：运行操作系统程序，操作硬件

用户态（User Mode）：运行用户程序

### 指令划分

特权指令：只能由操作系统使用、用户程序不能使用的指令。 举例：启动I/O 内存清零 修改程序状态字 设置时钟 允许/禁止终端 停机

非特权指令：用户程序可以使用的指令。 举例：控制转移 算数运算 取数指令 **访管指令**（使用户程序从用户态陷入内核态）

### 特权级别

**特权环：R0、R1、R2和R3**

R0相当于内核态，R3相当于用户态；

不同级别能够运行不同的指令集合；

### CPU状态之间的转换

**用户态--->内核态：**唯一途径是通过中断、异常、陷入机制（访管指令）

**内核态--->用户态：**设置程序状态字PSW

### 内核态与用户态的区别

- 内核态与用户态是操作系统的两种运行级别，当程序运行在3级特权级上时，就可以称之为运行在用户态。**因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；**

- 当程序运行在0级特权级上时，就可以称之为运行在内核态。

- 运行在用户态下的程序**不能直接访问操作系统内核数据结构和程序**。当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态（比如操作硬件）。

- 这两种状态的主要差别是

	> - 处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的
	> - 处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。

### 通常来说，以下三种情况会导致用户态到内核态的切换

- 系统调用

**用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。**

而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。

用户程序通常调用库函数，由库函数再调用系统调用，因此有的库函数会使用户程序进入内核态（只要库函数中某处调用了系统调用），有的则不会。

- 异常

当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如**缺页异常**。

- 外围设备的中断

**当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号**，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，

如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如**硬盘读写操作完成**，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

**这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。**



## IO过程

![深入剖析Linux IO原理和几种零拷贝机制的实现](IO.assets\v2-d084e90e6834a6eba094d9795543a3dc_1200x500.jpg)



## IO模型

阻塞IO（BIO）：IO操作时等待数据就绪

非阻塞IO：IO操作时询问数据是否就绪（查询数据是否就绪阶段是非阻塞的），如果没有不会阻塞等待就绪。适当的时候会重新询问。拷贝阶段仍然是阻塞的。

IO复用：包括select、poll、epoll

信号驱动sigio：

异步io（AIO）：线程发起数据操作后立刻处理其他事务。数据就绪后，主动拷贝到用户线程中（拷贝阶段也是非阻塞的）。线程直接使用数据。

NIO：（JAVA实现的）即IO复用

## IO复用

文件描述符：**当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。**

IO多路复用可以同时监视多个文件描述符，IO多路复用相比于多线程的优势在于系统的开销小，系统不必创建和维护进程或线程，**免去了线程或进程的切换带来的开销**。而操作系统支持IO多路复用的系统调用有select，poll和epoll。

### select

select的底层是一个fd_set的数据结构，本质上是一个long类型的**数组**，数组中每一个元素都对应于一个文件描述符，通过**轮询**所有的文件描述符来检查是否有事件发生。

【优点】：

- **可移植性好；**
- **连接数少并且连接都十分活跃**的情况下，效率也不错。

【缺点】：

- **可以监听的最大文件描述符数量为1024**（**因为内核写定了**）。
- 检查是否有事件发生是**采用轮询遍历**的方式，当文件描述符很多时开销很大。

### poll

poll与select差不多，但**poll的文件描述符没有最大数量的限制**，采用链表存储，但是**依然采用轮询遍历**的方式检查是否有事件发生。

### epoll

epoll是一种更加高效的IO多路复用的方式，它**可以监视的文件描述符数量突破了1024的限制（十万）**，同时不需要通过轮询遍历的方式去检查文件描述符上是否有事件发生，因为epoll_wait返回的就是有事件发生的文件描述符。本质上是**事件驱动**。

具体是通过**红黑树和就绪链表**实现的，红黑树存储所有的文件描述符，就绪链表存储有事件发生的文件描述符；

- **epoll_ctl**可以对文件描述符结点进行增、删、改、查，并且**告知内核注册回调函数（事件）**。
- 一旦**文件描述符上有事件发生时，那么内核将该文件描述符节点插入到就绪链表里面**
- 这时候epoll_wait将会接收到消息，并且**将数据拷贝到用户空间**。

表面上看epoll的性能最好，**但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好**，毕竟epoll的**通知机制需要很多函数回调。**