# 操作系统

## 进程

### 进程与线程

### 进程通讯

管道：匿名命名

信号量

共享内存

事件通知

套接字

消息队列

## IO

### IO模型

阻塞IO：

非阻塞IO：

IO复用：

信号驱动sigio：

异步io：

NIO：

### IO复用

文件描述符：**当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。**

IO多路复用可以同时监视多个文件描述符，IO多路复用相比于多线程的优势在于系统的开销小，系统不必创建和维护进程或线程，**免去了线程或进程的切换带来的开销**。而操作系统支持IO多路复用的系统调用有select，poll和epoll。

#### select

select的底层是一个fd_set的数据结构，本质上是一个long类型的数组，数组中每一个元素都对应于一个文件描述符，通过**轮询**所有的文件描述符来检查是否有事件发生。

【优点】：

- **可移植性好；**
- **连接数少并且连接都十分活跃**的情况下，效率也不错。

【缺点】：

- **可以监听的最大文件描述符数量为1024**（**因为内核写定了**）。
- 检查是否有事件发生是**采用轮询遍历**的方式，当文件描述符很多时开销很大。

#### poll

poll与select差不多，但**poll的文件描述符没有最大数量的限制**，但是**依然采用轮询遍历**的方式检查是否有事件发生。

#### epoll

epoll是一种更加高效的IO多路复用的方式，它**可以监视的文件描述符数量突破了1024的限制（十万）**，同时不需要通过轮询遍历的方式去检查文件描述符上是否有事件发生，因为epoll_wait返回的就是有事件发生的文件描述符。本质上是**事件驱动**。

具体是通过**红黑树和就绪链表**实现的，红黑树存储所有的文件描述符，就绪链表存储有事件发生的文件描述符；

- **epoll_ctl**可以对文件描述符结点进行增、删、改、查，并且**告知内核注册回调函数（事件）**。
- 一旦**文件描述符上有事件发生时，那么内核将该文件描述符节点插入到就绪链表里面**
- 这时候epoll_wait将会接收到消息，并且**将数据拷贝到用户空间**。

表面上看epoll的性能最好，**但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好**，毕竟epoll的**通知机制需要很多函数回调。**

## 死锁

## 内存管理

### 页面置换

FIFO先进先出
LRU最久未使用
LFU最少使用

### 页面管理

分段：段是根据逻辑进行拆分，例如主程序、子程序、数据等。段长不固定，且长段难以分配连续内存，容易出现难以利用的碎片。

分页：分页管理提高内存利用率，减少外部碎片，但是页长固定，内部会出现轻微浪费。主要的缺点是不方便按照逻辑组织信息。

段页式：先进行逻辑分段，再进行固定长度分页。段表——>页数、（块号）页表存储位置；页表——>页面的存储位置

## CPU调度算法

先来先服务

短进程优先

相同的时间片轮询

随机

## Linux