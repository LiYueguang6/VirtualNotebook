# 锁和封锁协议

## 表锁行锁

innodb支持行锁

## X锁和S锁

* 排它锁X锁又称为写锁。若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。这就保证了其它事务在T释放A上的锁之前不能再读取和修改A。 
* 共享锁S锁又称为读锁。若事务T对数据对象A加上S锁，则其它事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这就保证了其它事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。 

## 意向锁
支持多粒度加锁，提高效率（因为X锁是行锁，如果另外一个X锁想获取X锁，要先判断整个表有没有X锁，消耗资源），IS和IX都兼容，意向锁是表锁，

* 如果要对行加X行锁的话，有任何锁都不可以。

* 如果要加S行锁的话，X、IX锁都不可以。
* IS只在有X锁时不可以加，
* IX在有S锁时也不可以加。
* IS和IX都是S和X的先行锁。

## 三级封锁协议
1. 1级封锁协议是：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。 1级封锁协议可**防止丢失修改**，并保证事务T是**可恢复的**。在1级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，所以它**不能保证可重复读和不读"脏"数据**。 
2. 2级封锁协议是：1级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁。2级封锁协议除防止了丢失修改，还可**进一步防止读"脏"数据**。 
3. 3级封锁协议是：1级封锁协议加上事务T在读取数据R之前必须先对其加S锁，**直到事务结束才释放**。3级封锁协议除防止了丢失修改和不读'脏'数据外，还进一步**防止了不可重复读**。

## 死锁

**产生死锁的四个必要条件：**

（1） **互斥**条件：一个资源每次只能被一个进程使用。
（2） **请求与保持**条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
（3） **不剥夺**条件：进程已获得的资源，在末使用完之前，不能强行剥夺。
（4） **循环等待**条件：若干进程之间形成一种头尾相接的循环等待资源关系。

 这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

##### 解决办法

1. 超时（需等待）
2. 死锁检测，在需要的数据被其他事务锁住的时候，进行检测，释放死锁链条中某一个事务（需消耗资源）